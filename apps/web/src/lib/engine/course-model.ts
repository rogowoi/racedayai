/**
 * RaceDayAI – Course Model Integration
 * ====================================
 *
 * Provides course-specific predictions and adjustments:
 *   1. Course catalog lookup (fuzzy matching)
 *   2. Course-specific difficulty factors
 *   3. Adjusted time predictions for course characteristics
 *   4. Course-specific performance benchmarks
 *
 * Data from pre-computed JSON files:
 *   - race-catalog.json: all 195+ race venues with stats
 *   - course-benchmarks.json: per-course performance benchmarks
 *   - course-difficulty.json: course difficulty factors (generated by agents)
 */

import type { Gender, AgeGroup } from "./statistics";

// ── Types ──────────────────────────────────────────────────────

export interface CourseStats {
  medianSec: number;
  meanSec: number;
  p10Sec: number;
  p90Sec: number;
  minSec: number;
  maxSec: number;
}

export interface CourseSegmentStats {
  swimMedianSec: number;
  bikeMedianSec: number;
  runMedianSec: number;
}

export interface DifficultyFactor {
  tier: "easy" | "moderate" | "hard" | "very-hard";
  factor: number; // >1.0 = slower, <1.0 = faster
  reasons: string[];
}

export interface CourseContext {
  /** Whether we found a matching course */
  matched: boolean;

  /** Matched course name from catalog */
  courseKey: string | null;

  /** Full course name as shown in catalog */
  courseName: string | null;

  /** Course difficulty assessment */
  difficulty: DifficultyFactor | null;

  /** Typical median finish time for this course */
  medianFinishSec: number | null;

  /** Time adjustment factor (compared to global median) */
  adjustmentFactor: number | null;

  /** Course-specific benchmarks if available */
  benchmarks: {
    gender: Gender;
    ageGroup: AgeGroup;
    medianSec: number;
    swimMedianSec: number;
    bikeMedianSec: number;
    runMedianSec: number;
  } | null;
}

// ── Race Catalog Type ──────────────────────────────────────────

interface RaceCatalogEntry {
  event_location: string;
  metadata: {
    raw_name: string;
    is_championship: boolean;
    location: string;
    event_type: string;
  };
  stats: {
    total_athletes: number;
    years: number[];
    finish_time: {
      median_sec: number;
      mean_sec: number;
      p10_sec: number;
      p90_sec: number;
      min_sec: number;
      max_sec: number;
      stdev_sec: number;
    };
    segments: {
      swim: {
        median_sec: number;
        mean_sec: number;
        pct_of_total: number;
      };
      bike: {
        median_sec: number;
        mean_sec: number;
        pct_of_total: number;
      };
      run: {
        median_sec: number;
        mean_sec: number;
        pct_of_total: number;
      };
    };
  };
}

interface CourseBenchmarkEntry {
  event_location: string;
  by_gender: Record<
    string,
    {
      count: number;
      finish_time: {
        median_sec: number;
        mean_sec: number;
        p10_sec: number;
        p90_sec: number;
      };
      segments: {
        swim: { median_sec: number; mean_sec: number };
        bike: { median_sec: number; mean_sec: number };
        run: { median_sec: number; mean_sec: number };
      };
      by_age_group?: Record<
        string,
        {
          count: number;
          median_sec: number;
        }
      >;
    }
  >;
}

interface CourseDifficultyEntry {
  courseKey: string;
  difficulty_tier: string; // from generated JSON
  adjusted_factor: number;
  simple_factor?: number;
}

// ── Lazy-loaded data ───────────────────────────────────────────

let raceCatalog: RaceCatalogEntry[] | null = null;
let courseBenchmarks: CourseBenchmarkEntry[] | null = null;
let courseDifficulties: Record<string, CourseDifficultyEntry> | null = null;

async function loadRaceCatalog(): Promise<RaceCatalogEntry[] | null> {
  if (raceCatalog !== null) return raceCatalog;
  try {
    const data = await import("@/data/race-catalog.json");
    raceCatalog = Array.isArray(data.default) ? data.default : [];
    return raceCatalog;
  } catch {
    return null;
  }
}

async function loadCourseBenchmarks(): Promise<CourseBenchmarkEntry[] | null> {
  if (courseBenchmarks !== null) return courseBenchmarks;
  try {
    const data = await import("@/data/course-benchmarks.json");
    courseBenchmarks = Array.isArray(data.default) ? (data.default as any[]) : [];
    return courseBenchmarks;
  } catch {
    return null;
  }
}

async function loadCourseDifficulties(): Promise<
  Record<string, CourseDifficultyEntry> | null
> {
  if (courseDifficulties !== null) return courseDifficulties;
  try {
    const data = await import("@/data/course-difficulty.json");
    const rawData = data.default as any;
    courseDifficulties = {};

    // Handle the structure from generated course-difficulty.json
    if (rawData.courses) {
      for (const [courseKey, entry] of Object.entries(rawData.courses)) {
        courseDifficulties[courseKey] = {
          courseKey,
          difficulty_tier: (entry as any).difficulty_tier,
          adjusted_factor: (entry as any).adjusted_factor,
        };
      }
    }

    return courseDifficulties;
  } catch {
    return null;
  }
}

// ── Helpers ────────────────────────────────────────────────────

/**
 * Normalize a string for fuzzy matching: lowercase, remove punctuation, trim.
 */
function normalizeForMatching(s: string): string {
  return s
    .toLowerCase()
    .replace(/[^\w\s]/g, "")
    .trim();
}

/**
 * Simple fuzzy match: check if all tokens from the query appear in the target.
 * Returns a score: 0 = no match, higher = better match.
 */
function fuzzyScore(query: string, target: string): number {
  const queryNorm = normalizeForMatching(query);
  const targetNorm = normalizeForMatching(target);

  if (!queryNorm || !targetNorm) return 0;

  const queryTokens = queryNorm.split(/\s+/);
  const targetTokens = targetNorm.split(/\s+/);

  // Count how many query tokens appear in the target
  let matchCount = 0;
  for (const qToken of queryTokens) {
    for (const tToken of targetTokens) {
      if (tToken.includes(qToken) || qToken.includes(tToken)) {
        matchCount++;
        break;
      }
    }
  }

  // Score = matched tokens / total query tokens
  // Also boost if it's a substring match
  const baseScore = matchCount / queryTokens.length;
  const substringBoost = targetNorm.includes(queryNorm) ? 0.5 : 0;

  return baseScore + substringBoost;
}

// ── Public API ─────────────────────────────────────────────────

/**
 * Find a matching course in the catalog by race name (fuzzy match).
 *
 * Returns the courseKey (event_location) if found, null otherwise.
 */
export async function findMatchingCourse(raceName: string): Promise<string | null> {
  const catalog = await loadRaceCatalog();
  if (!catalog || !raceName) return null;

  let bestMatch: { courseKey: string; score: number } | null = null;

  for (const entry of catalog) {
    const score = fuzzyScore(raceName, entry.event_location);
    if (score > 0.5) {
      if (!bestMatch || score > bestMatch.score) {
        bestMatch = { courseKey: entry.event_location, score };
      }
    }
  }

  return bestMatch?.courseKey ?? null;
}

/**
 * Get course difficulty factor and tier for a matched course.
 *
 * Returns null if no difficulty data available (graceful fallback).
 */
export async function getCourseDifficulty(
  courseKey: string,
): Promise<DifficultyFactor | null> {
  const difficulties = await loadCourseDifficulties();
  if (!difficulties || !courseKey) return null;

  const entry = difficulties[courseKey];
  if (!entry) return null;

  // Map difficulty tier string to our enum
  let tier: "easy" | "moderate" | "hard" | "very-hard" = "moderate";
  const tierStr = entry.difficulty_tier.toLowerCase();
  if (tierStr === "easy") tier = "easy";
  else if (tierStr === "hard") tier = "hard";
  else if (tierStr.includes("very")) tier = "very-hard";

  return {
    tier,
    factor: entry.adjusted_factor,
    reasons: [`Course difficulty tier: ${entry.difficulty_tier}`],
  };
}

/**
 * Adjust a base time prediction for course-specific difficulty.
 *
 * If no difficulty data, returns original time.
 */
export async function getCourseAdjustedTime(
  baseTimeSec: number,
  courseKey: string,
  _gender: string,
): Promise<number> {
  const difficulty = await getCourseDifficulty(courseKey);
  if (!difficulty) return baseTimeSec;

  // Apply difficulty factor as a multiplier
  return Math.round(baseTimeSec * difficulty.factor);
}

/**
 * Get course-specific benchmarks for a gender and age group.
 *
 * Returns median times and segment splits if available, null otherwise.
 */
export async function getCourseBenchmarks(
  courseKey: string,
  gender: Gender,
  _ageGroup: AgeGroup,
): Promise<{
  medianSec: number;
  swimMedianSec: number;
  bikeMedianSec: number;
  runMedianSec: number;
} | null> {
  const benchmarks = await loadCourseBenchmarks();
  if (!benchmarks || !courseKey || !gender) return null;

  const entry = benchmarks.find((e) => e.event_location === courseKey);
  if (!entry) return null;

  const genderData = entry.by_gender[gender];
  if (!genderData) return null;

  // For now, return overall gender benchmarks
  // In future, could drill down into age group if by_age_group is populated
  return {
    medianSec: genderData.finish_time.median_sec,
    swimMedianSec: genderData.segments.swim.median_sec,
    bikeMedianSec: genderData.segments.bike.median_sec,
    runMedianSec: genderData.segments.run.median_sec,
  };
}

/**
 * Build full course context for a race.
 *
 * This wraps all course-specific insights into a single object.
 */
export async function buildCourseContext(params: {
  raceName: string;
  gender?: Gender;
  ageGroup?: AgeGroup;
}): Promise<CourseContext> {
  const { raceName, gender, ageGroup } = params;

  // Try to find a matching course
  const courseKey = await findMatchingCourse(raceName);

  if (!courseKey || !gender || !ageGroup) {
    return {
      matched: false,
      courseKey: null,
      courseName: null,
      difficulty: null,
      medianFinishSec: null,
      adjustmentFactor: null,
      benchmarks: null,
    };
  }

  // Load catalog to get full course name
  const catalog = await loadRaceCatalog();
  const catalogEntry = catalog?.find((e) => e.event_location === courseKey);

  // Get difficulty
  const difficulty = await getCourseDifficulty(courseKey);

  // Get benchmarks
  const benchmarks = await getCourseBenchmarks(courseKey, gender, ageGroup);

  return {
    matched: true,
    courseKey,
    courseName: catalogEntry?.event_location ?? null,
    difficulty,
    medianFinishSec: benchmarks?.medianSec ?? catalogEntry?.stats.finish_time.median_sec ?? null,
    adjustmentFactor: difficulty?.factor ?? null,
    benchmarks: benchmarks
      ? {
          gender,
          ageGroup,
          medianSec: benchmarks.medianSec,
          swimMedianSec: benchmarks.swimMedianSec,
          bikeMedianSec: benchmarks.bikeMedianSec,
          runMedianSec: benchmarks.runMedianSec,
        }
      : null,
  };
}
