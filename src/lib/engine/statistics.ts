/**
 * RaceDayAI – Statistical Engine
 * ================================
 * Data-driven predictions based on 840,075 IRONMAN 70.3 race records.
 *
 * Provides:
 *   1. Cohort-based percentile placement (where does this time rank?)
 *   2. Predicted finish time distributions by gender × age group
 *   3. Data-driven split ratios instead of hardcoded IF values
 *   4. Confidence intervals for all predictions
 *
 * All data comes from pre-computed JSON lookups generated by
 * `scripts/analytics/02_fit_distributions.py` and
 * `scripts/analytics/03_split_ratio_analysis.py`.
 */

import cohortDistributions from "@/data/cohort-distributions.json";
import splitRatios from "@/data/split-ratios.json";

// ── Types ──────────────────────────────────────────────────────

export type Gender = "M" | "F";

export type AgeGroup =
  | "18-24"
  | "25-29"
  | "30-34"
  | "35-39"
  | "40-44"
  | "45-49"
  | "50-54"
  | "55-59"
  | "60-64"
  | "65-69"
  | "70-74"
  | "75-79";

export type Segment = "swim" | "bike" | "run" | "total";

export interface CohortStats {
  mean: number;
  median: number;
  std: number;
  p10: number;
  p25: number;
  p75: number;
  p90: number;
  min: number;
  max: number;
  count: number;
}

export interface LogNormalFit {
  shape: number;
  loc: number;
  scale: number;
}

export interface CohortSegment {
  fit: LogNormalFit;
  stats: CohortStats;
}

export interface PercentileResult {
  percentile: number; // 0-100, where lower = faster
  label: string; // "Top 15%", "Middle of pack", etc.
  fasterThanPct: number; // % of cohort you're faster than
}

export interface SplitRecommendation {
  swimPct: number; // % of total time on swim
  bikePct: number; // % of total time on bike
  runPct: number; // % of total time on run
  swimSec: number; // predicted seconds
  bikeSec: number; // predicted seconds
  runSec: number; // predicted seconds
}

export interface CohortPrediction {
  gender: Gender;
  ageGroup: AgeGroup;
  cohortKey: string;
  sampleSize: number;

  // Predicted times (seconds) at various target percentiles
  segments: {
    swim: CohortStats;
    bike: CohortStats;
    run: CohortStats;
    total: CohortStats;
  };

  // Recommended split ratios for a target percentile
  splitRecommendation: SplitRecommendation | null;

  // Where a given time falls in this cohort
  percentilePlacement: PercentileResult | null;
}

export interface StatisticalContext {
  /** Whether statistical data was available for this cohort */
  available: boolean;

  /** Total records in the dataset */
  datasetSize: number;

  /** Cohort-specific predictions */
  cohort: CohortPrediction | null;

  /** Confidence interval for predicted total time */
  confidenceInterval: {
    p10: number; // optimistic (seconds)
    p50: number; // median (seconds)
    p90: number; // conservative (seconds)
  } | null;

  /** Data-driven IF recommendation (replaces hardcoded) */
  recommendedIF: number | null;
}

export interface FullStatisticalContext extends StatisticalContext {
  /** Course-specific insights if matched */
  course?: {
    matched: boolean;
    courseKey: string | null;
    courseName: string | null;
    difficulty?: {
      tier: "easy" | "moderate" | "hard" | "very-hard";
      factor: number;
      reasons: string[];
    } | null;
    medianFinishSec: number | null;
    adjustmentFactor: number | null;
    benchmarks?: {
      gender: Gender;
      ageGroup: AgeGroup;
      medianSec: number;
      swimMedianSec: number;
      bikeMedianSec: number;
      runMedianSec: number;
    } | null;
  };

  /** Run fade prediction based on planned bike intensity */
  fadePrediction?: {
    paceSlowdownPct: number;
    estimatedTimeAddedSec: number;
    confidenceInterval: {
      lower: number;
      upper: number;
    } | null;
  } | null;

  /** Weather impact prediction */
  weatherImpact?: {
    combinedImpactPct: number;
    tempImpactPct: number;
    windImpactPct: number;
    humidityImpactPct: number;
    riskLevel: string;
    adjustedTimeSec: number;
  } | null;

  /** Year-adjusted trend prediction */
  trendAdjustment?: {
    adjustmentSec: number;
    adjustmentPct: number;
    yearCoefficient: number;
    confidenceNote: string;
    baselineYear: number;
    targetYear: number;
    segmentTrends: {
      swim: { secPerYear: number; direction: string };
      bike: { secPerYear: number; direction: string };
      run: { secPerYear: number; direction: string };
    };
  } | null;
}

// ── Helpers ────────────────────────────────────────────────────

function ageToGroup(age: number): AgeGroup {
  if (age < 18) return "18-24";
  if (age < 25) return "18-24";
  if (age < 30) return "25-29";
  if (age < 35) return "30-34";
  if (age < 40) return "35-39";
  if (age < 45) return "40-44";
  if (age < 50) return "45-49";
  if (age < 55) return "50-54";
  if (age < 60) return "55-59";
  if (age < 65) return "60-64";
  if (age < 70) return "65-69";
  if (age < 75) return "70-74";
  return "75-79";
}

function getCohortKey(gender: Gender, ageGroup: AgeGroup): string {
  return `${gender}_${ageGroup}`;
}

/**
 * Approximate the CDF of a log-normal distribution.
 *
 * CDF(x) = Φ((ln(x) - μ) / σ)
 *
 * where μ = ln(scale) and σ = shape (scipy convention).
 * Φ is the standard normal CDF.
 */
function logNormalCdf(x: number, fit: LogNormalFit): number {
  if (x <= 0) return 0;

  const sigma = fit.shape;
  const mu = Math.log(fit.scale);
  const z = (Math.log(x) - mu) / sigma;

  // Approximation of standard normal CDF (Abramowitz & Stegun)
  return normalCdf(z);
}

/**
 * Standard normal CDF approximation.
 * Accurate to ~1e-7 using Abramowitz & Stegun formula 26.2.17.
 */
function normalCdf(z: number): number {
  if (z < -8) return 0;
  if (z > 8) return 1;

  const isNeg = z < 0;
  if (isNeg) z = -z;

  const p = 0.2316419;
  const b1 = 0.319381530;
  const b2 = -0.356563782;
  const b3 = 1.781477937;
  const b4 = -1.821255978;
  const b5 = 1.330274429;

  const t = 1.0 / (1.0 + p * z);
  const pdf = Math.exp(-0.5 * z * z) / Math.sqrt(2 * Math.PI);
  const poly = t * (b1 + t * (b2 + t * (b3 + t * (b4 + t * b5))));
  const cdf = 1.0 - pdf * poly;

  return isNeg ? 1.0 - cdf : cdf;
}

/**
 * Inverse log-normal: given a percentile (0-1), return the time in seconds.
 */
function logNormalQuantile(p: number, fit: LogNormalFit): number {
  const sigma = fit.shape;
  const mu = Math.log(fit.scale);
  const z = normalQuantile(p);
  return Math.exp(mu + sigma * z);
}

/**
 * Inverse standard normal (quantile function).
 * Uses rational approximation (Peter Acklam's algorithm).
 */
function normalQuantile(p: number): number {
  if (p <= 0) return -Infinity;
  if (p >= 1) return Infinity;
  if (p === 0.5) return 0;

  // Coefficients
  const a1 = -3.969683028665376e1;
  const a2 = 2.209460984245205e2;
  const a3 = -2.759285104469687e2;
  const a4 = 1.383577518672690e2;
  const a5 = -3.066479806614716e1;
  const a6 = 2.506628277459239e0;

  const b1 = -5.447609879822406e1;
  const b2 = 1.615858368580409e2;
  const b3 = -1.556989798598866e2;
  const b4 = 6.680131188771972e1;
  const b5 = -1.328068155288572e1;

  const c1 = -7.784894002430293e-3;
  const c2 = -3.223964580411365e-1;
  const c3 = -2.400758277161838e0;
  const c4 = -2.549732539343734e0;
  const c5 = 4.374664141464968e0;
  const c6 = 2.938163982698783e0;

  const d1 = 7.784695709041462e-3;
  const d2 = 3.224671290700398e-1;
  const d3 = 2.445134137142996e0;
  const d4 = 3.754408661907416e0;

  const pLow = 0.02425;
  const pHigh = 1 - pLow;

  let q: number;
  let r: number;

  if (p < pLow) {
    q = Math.sqrt(-2 * Math.log(p));
    return (
      (((((c1 * q + c2) * q + c3) * q + c4) * q + c5) * q + c6) /
      ((((d1 * q + d2) * q + d3) * q + d4) * q + 1)
    );
  } else if (p <= pHigh) {
    q = p - 0.5;
    r = q * q;
    return (
      ((((((a1 * r + a2) * r + a3) * r + a4) * r + a5) * r + a6) * q) /
      (((((b1 * r + b2) * r + b3) * r + b4) * r + b5) * r + 1)
    );
  } else {
    q = Math.sqrt(-2 * Math.log(1 - p));
    return (
      -(((((c1 * q + c2) * q + c3) * q + c4) * q + c5) * q + c6) /
      ((((d1 * q + d2) * q + d3) * q + d4) * q + 1)
    );
  }
}

function percentileLabel(pct: number): string {
  if (pct <= 5) return "Elite (Top 5%)";
  if (pct <= 10) return "Top 10%";
  if (pct <= 25) return "Top 25%";
  if (pct <= 40) return "Above average";
  if (pct <= 60) return "Middle of pack";
  if (pct <= 75) return "Below average";
  if (pct <= 90) return "Back of pack";
  return "Final finishers";
}

// ── Public API ─────────────────────────────────────────────────

/**
 * Get the cohort data for a given gender and age group.
 */
export function getCohortData(
  gender: Gender,
  ageGroup: AgeGroup,
): CohortSegment | null {
  const key = getCohortKey(gender, ageGroup);
  const cohorts = (cohortDistributions as any).cohorts;
  return cohorts[key] ?? null;
}

/**
 * Calculate what percentile a given time falls at within a cohort.
 *
 * Returns the percentile (0-100) where lower = faster.
 * e.g., percentile 10 = faster than 90% of the cohort.
 */
export function getPercentile(
  timeSec: number,
  gender: Gender,
  ageGroup: AgeGroup,
  segment: Segment = "total",
): PercentileResult | null {
  const key = getCohortKey(gender, ageGroup);
  const cohorts = (cohortDistributions as any).cohorts;
  const cohort = cohorts[key];

  if (!cohort || !cohort[segment]) return null;

  const fit = cohort[segment].fit as LogNormalFit;
  const percentile = logNormalCdf(timeSec, fit) * 100;
  const rounded = Math.round(percentile * 10) / 10;

  return {
    percentile: rounded,
    label: percentileLabel(rounded),
    fasterThanPct: Math.round((100 - rounded) * 10) / 10,
  };
}

/**
 * Get predicted times at a target percentile for a cohort.
 *
 * targetPercentile: 0-100 where lower = faster.
 * e.g., 25 means "I want to finish in the top 25% of my cohort."
 */
export function getPredictedTimes(
  gender: Gender,
  ageGroup: AgeGroup,
  targetPercentile: number = 50,
): { swim: number; bike: number; run: number; total: number } | null {
  const key = getCohortKey(gender, ageGroup);
  const cohorts = (cohortDistributions as any).cohorts;
  const cohort = cohorts[key];

  if (!cohort) return null;

  const p = targetPercentile / 100;
  const result: any = {};

  for (const seg of ["swim", "bike", "run", "total"] as Segment[]) {
    if (cohort[seg]?.fit) {
      result[seg] = Math.round(logNormalQuantile(p, cohort[seg].fit));
    } else {
      result[seg] = null;
    }
  }

  return result;
}

/**
 * Get recommended split ratios for a target percentile.
 *
 * Uses the split-ratios.json data which provides swim/bike/run %
 * breakdowns for each cohort at each target percentile.
 */
export function getSplitRecommendation(
  gender: Gender,
  ageGroup: AgeGroup,
  targetPercentile: number = 50,
  totalTimeSec?: number,
): SplitRecommendation | null {
  const key = getCohortKey(gender, ageGroup);
  const cohortData = (splitRatios as any).by_cohort_and_percentile[key];

  if (!cohortData?.by_percentile) {
    // Fall back to overall percentile bands
    return getSplitFromBands(targetPercentile, totalTimeSec);
  }

  // Find nearest available percentile
  const available = Object.keys(cohortData.by_percentile).map(Number);
  const nearest = available.reduce((prev, curr) =>
    Math.abs(curr - targetPercentile) < Math.abs(prev - targetPercentile)
      ? curr
      : prev,
  );

  const band = cohortData.by_percentile[String(nearest)];
  if (!band) return getSplitFromBands(targetPercentile, totalTimeSec);

  const swimPct = band.swim_pct ?? 11;
  const bikePct = band.bike_pct ?? 52;
  const runPct = band.run_pct ?? 35;

  const total = totalTimeSec ?? band.avg_total_min * 60;

  return {
    swimPct,
    bikePct,
    runPct,
    swimSec: Math.round((total * swimPct) / 100),
    bikeSec: Math.round((total * bikePct) / 100),
    runSec: Math.round((total * runPct) / 100),
  };
}

function getSplitFromBands(
  targetPercentile: number,
  totalTimeSec?: number,
): SplitRecommendation | null {
  const bands = (splitRatios as any).by_percentile_band;

  let bandKey: string;
  if (targetPercentile <= 10) bandKey = "top_10pct";
  else if (targetPercentile <= 25) bandKey = "top_25pct";
  else if (targetPercentile <= 50) bandKey = "25_50pct";
  else if (targetPercentile <= 75) bandKey = "50_75pct";
  else bandKey = "bottom_25pct";

  const band = bands[bandKey];
  if (!band?.splits) return null;

  const swimPct = band.splits.swim?.mean ?? 11;
  const bikePct = band.splits.bike?.mean ?? 52;
  const runPct = band.splits.run?.mean ?? 35;

  const total = totalTimeSec ?? band.avg_total_min * 60;

  return {
    swimPct,
    bikePct,
    runPct,
    swimSec: Math.round((total * swimPct) / 100),
    bikeSec: Math.round((total * bikePct) / 100),
    runSec: Math.round((total * runPct) / 100),
  };
}

/**
 * Derive a data-driven Intensity Factor from cohort data.
 *
 * Instead of hardcoded IF values (0.92/0.88/0.78/0.70), we calculate
 * what bike power proportion is implied by the statistical finish times.
 *
 * For 70.3: the cohort median bike time and FTP give a natural IF.
 * This function computes the IF that would produce the cohort-median
 * bike time for a given FTP.
 */
export function getDataDrivenIF(
  ftp: number,
  gender: Gender,
  ageGroup: AgeGroup,
  targetPercentile: number = 50,
  courseDistanceKm: number = 90,
): number | null {
  const times = getPredictedTimes(gender, ageGroup, targetPercentile);
  if (!times?.bike) return null;

  // Predicted bike time -> speed -> power -> IF
  const bikeSec = times.bike;
  const bikeHours = bikeSec / 3600;
  const speedKph = courseDistanceKm / bikeHours;

  // Inverse of Speed = 5.8 * Power^(1/3)
  // Power = (Speed / 5.8)^3
  const impliedPower = Math.pow(speedKph / 5.8, 3);

  // IF = NP / FTP
  const impliedIF = impliedPower / ftp;

  // Clamp to reasonable range
  return Math.max(0.55, Math.min(0.95, Math.round(impliedIF * 1000) / 1000));
}

/**
 * Build a full statistical context for a race plan.
 *
 * This is the main entry point called by the plan generator.
 * It wraps all statistical insights into a single object.
 */
export function buildStatisticalContext(params: {
  gender?: Gender;
  age?: number;
  ageGroup?: AgeGroup;
  ftp?: number;
  distanceCategory?: string;
  targetPercentile?: number;
  predictedTotalSec?: number;
}): StatisticalContext {
  const {
    gender,
    age,
    ageGroup: providedAG,
    ftp,
    distanceCategory,
    targetPercentile = 50,
    predictedTotalSec,
  } = params;

  // Only works for 70.3 currently (our dataset)
  const is703 = distanceCategory === "70.3";

  if (!gender || (!age && !providedAG) || !is703) {
    return {
      available: false,
      datasetSize: (cohortDistributions as any).metadata?.total_records ?? 0,
      cohort: null,
      confidenceInterval: null,
      recommendedIF: null,
    };
  }

  const ageGroup = providedAG ?? ageToGroup(age!);
  const key = getCohortKey(gender, ageGroup);
  const cohorts = (cohortDistributions as any).cohorts;
  const cohort = cohorts[key];

  if (!cohort) {
    return {
      available: false,
      datasetSize: (cohortDistributions as any).metadata?.total_records ?? 0,
      cohort: null,
      confidenceInterval: null,
      recommendedIF: null,
    };
  }

  // Build segments
  const segments: any = {};
  for (const seg of ["swim", "bike", "run", "total"] as const) {
    segments[seg] = cohort[seg]?.stats ?? null;
  }

  // Get predicted times
  const predictedTimes = getPredictedTimes(gender, ageGroup, targetPercentile);

  // Get split recommendation
  const splitRec = getSplitRecommendation(
    gender,
    ageGroup,
    targetPercentile,
    predictedTotalSec ?? (predictedTimes?.total ?? undefined),
  );

  // Percentile placement if we have a predicted total
  let placement: PercentileResult | null = null;
  if (predictedTotalSec) {
    placement = getPercentile(predictedTotalSec, gender, ageGroup, "total");
  }

  // Confidence interval from distribution
  let confidenceInterval: StatisticalContext["confidenceInterval"] = null;
  if (cohort.total?.fit) {
    const fit = cohort.total.fit as LogNormalFit;
    confidenceInterval = {
      p10: Math.round(logNormalQuantile(0.1, fit)),
      p50: Math.round(logNormalQuantile(0.5, fit)),
      p90: Math.round(logNormalQuantile(0.9, fit)),
    };
  }

  // Data-driven IF
  let recommendedIF: number | null = null;
  if (ftp) {
    recommendedIF = getDataDrivenIF(
      ftp,
      gender,
      ageGroup,
      targetPercentile,
      90, // 70.3 bike = 90km
    );
  }

  return {
    available: true,
    datasetSize: (cohortDistributions as any).metadata?.total_records ?? 0,
    cohort: {
      gender,
      ageGroup,
      cohortKey: key,
      sampleSize: cohort.count,
      segments,
      splitRecommendation: splitRec,
      percentilePlacement: placement,
    },
    confidenceInterval,
    recommendedIF,
  };
}

/**
 * Build a comprehensive statistical context including course and fade predictions.
 *
 * This combines:
 *   1. Standard cohort-based statistical context
 *   2. Course-specific insights (if course is matched)
 *   3. Run fade prediction (if bike intensity data available)
 *   4. Year-based trend adjustment (if raceYear provided)
 *
 * Returns a FullStatisticalContext with all insights.
 */
export async function buildFullContext(params: {
  gender?: Gender;
  age?: number;
  ageGroup?: AgeGroup;
  ftp?: number;
  distanceCategory?: string;
  targetPercentile?: number;
  predictedTotalSec?: number;
  raceName?: string;
  bikePlanIF?: number;
  raceYear?: number;
  weatherTempC?: number;
  weatherWindKph?: number;
  weatherHumidityPct?: number;
}): Promise<FullStatisticalContext> {
  const {
    raceName,
    bikePlanIF,
    raceYear,
    weatherTempC,
    weatherWindKph,
    weatherHumidityPct,
  } = params;

  // Resolve ageGroup from age if not explicitly provided
  const resolvedAgeGroup = params.ageGroup ?? (params.age ? ageToGroup(params.age) : undefined);

  // Build the standard statistical context first
  const baseContext = buildStatisticalContext(params);

  // Dynamic imports for course and fade modules
  let courseContext: FullStatisticalContext["course"] = undefined;
  let fadePrediction: FullStatisticalContext["fadePrediction"] = undefined;

  // Try to add course-specific context
  if (raceName && params.gender && resolvedAgeGroup) {
    try {
      const { buildCourseContext } = await import("./course-model");
      const courseData = await buildCourseContext({
        raceName,
        gender: params.gender,
        ageGroup: resolvedAgeGroup,
      });

      courseContext = {
        matched: courseData.matched,
        courseKey: courseData.courseKey,
        courseName: courseData.courseName,
        difficulty: courseData.difficulty ?? undefined,
        medianFinishSec: courseData.medianFinishSec,
        adjustmentFactor: courseData.adjustmentFactor,
        benchmarks: courseData.benchmarks ?? undefined,
      };
    } catch {
      // Course module not available or error loading data
      courseContext = {
        matched: false,
        courseKey: null,
        courseName: null,
        medianFinishSec: null,
        adjustmentFactor: null,
      };
    }
  }

  // Try to add fade prediction
  if (bikePlanIF && params.gender && resolvedAgeGroup) {
    try {
      const { getRecommendedRunAdjustment } = await import("./fade-model");
      const fadePercent = await getRecommendedRunAdjustment(
        bikePlanIF,
        params.gender,
        resolvedAgeGroup,
      );

      // Estimate time loss: assume 21.1km run at ~6 min/km base (~7596 sec)
      const baseRunTimeSec = 21.1 * 6 * 60; // ~7596 sec
      const estimatedTimeAdded = Math.round((baseRunTimeSec * fadePercent) / 100);

      fadePrediction = {
        paceSlowdownPct: fadePercent,
        estimatedTimeAddedSec: estimatedTimeAdded,
        confidenceInterval: {
          lower: Math.max(0, fadePercent - 2),
          upper: Math.min(30, fadePercent + 2),
        },
      };
    } catch {
      // Fade model not available or error loading data
      fadePrediction = null;
    }
  }

  // Try to add weather impact prediction
  let weatherImpact: FullStatisticalContext["weatherImpact"] = undefined;
  if (
    weatherTempC !== undefined &&
    weatherWindKph !== undefined &&
    weatherHumidityPct !== undefined &&
    params.predictedTotalSec !== undefined
  ) {
    try {
      const { buildWeatherContext } = await import("./weather-model");
      const weatherData = await buildWeatherContext({
        tempC: weatherTempC,
        windKph: weatherWindKph,
        humidityPct: weatherHumidityPct,
        basePredictionSec: params.predictedTotalSec,
      });

      weatherImpact = weatherData ?? undefined;
    } catch {
      // Weather model not available or error loading data
      weatherImpact = null;
    }
  }

  // Try to add year-based trend adjustment
  let trendAdjustment: FullStatisticalContext["trendAdjustment"] = undefined;
  if (raceYear && params.gender && resolvedAgeGroup) {
    try {
      const { getYearAdjustment } = await import("./trends-model");
      const trend = await getYearAdjustment(raceYear, params.gender, resolvedAgeGroup);
      trendAdjustment = {
        adjustmentSec: trend.cohortSpecific?.adjustmentSec ?? trend.overall.adjustmentSec,
        adjustmentPct: trend.cohortSpecific?.adjustmentPct ?? trend.overall.adjustmentPct,
        yearCoefficient: trend.cohortSpecific?.yearCoefficient ?? trend.overall.yearCoefficient,
        confidenceNote: trend.cohortSpecific?.confidenceNote ?? trend.overall.confidenceNote,
        baselineYear: trend.overall.baselineYear,
        targetYear: raceYear,
        segmentTrends: trend.segmentTrends,
      };
    } catch {
      // Trends model not available or error loading data
      trendAdjustment = null;
    }
  }

  return {
    ...baseContext,
    course: courseContext,
    fadePrediction,
    weatherImpact,
    trendAdjustment,
  };
}
